<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>attempt at CodeMirror + in-place MathJax</title>
    <link rel="stylesheet" href="CodeMirror/lib/codemirror.css">
    <script src="CodeMirror/lib/codemirror.js"></script>
    <script src="CodeMirror/mode/markdown/markdown.js"></script>
    <script src="CodeMirror/mode/xml/xml.js"></script>
    <link rel="stylesheet" href="CodeMirror/doc/docs.css">

    <style type="text/css">
      .CodeMirror { border: 1px solid silver; border-width: 1px 2px; }
      .CodeMirror { font-family: sans-serif; }
      .cm-header { font-size: 150%; }
    </style>

    <script type="text/javascript" src="file:///usr/share/javascript/mathjax/unpacked/MathJax.js?config=TeX-AMS_HTML"></script>
    <script> window.MathJax || document.write(
      '<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"><\/script>');
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
        },
      });
    </script>

    <!-- I'm a JS noob, so jQuery is my only hope of writing somewhat portable code ;-).
         Drop ".min" to get non-minified source for debugging. -->
    <script type="text/javascript" src="file:///usr/share/javascript/jquery/jquery.js"></script>
    <script> window.jQuery || document.write(
      '<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.1/jquery.min.js"><\/script>');
    </script>
  </head>
  <body>
    <h1>attempt at CodeMirror + in-place MathJax</h1>

    <form><textarea id="code" name="code"># A First Level Header

**Bold** and *italic* text in a normal paragraph.

Foo $\sum^y_z x$ bar.

## A Second Level Header

$$\sum^b_c a$$
</textarea></form>
    <script id="script">
      "use strict";

      var editor = CodeMirror.fromTextArea(document.getElementById("code"),
                                           {lineNumbers: true,
                                            lineWrapping: true,
                                            mode: {name: "markdown",
                                                   underscoresBreakWords: false}});
      var doc = editor.getDoc();

      // Return negative / 0 / positive.
      function posCmp(a, b) {
        return (b.line - a.line) || (b.ch - a.ch);
      }

      // TODO: pass doc, editor as needed.

      // If cursor is inside a formula, we don't render it until the
      // cursor leaves it.  To cleanly detect when that happens we
      // still markText() it but without replacedWith and store the
      // marker here.
      var unrenderedMath = null;

      function processMath(from, to) {
        var text = editor.getRange(from, to);
        var elem = $("<span>").text(text)[0];
        var cursor = doc.getCursor();
        console.log("processMath", text, elem,
                    posCmp(from, cursor), posCmp(cursor, to));
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, elem]);
        MathJax.Hub.Queue(function() {
          // TODO: behavior during selection?
          var cursor = doc.getCursor();
          if(posCmp(from, cursor) > 0 && posCmp(cursor, to) > 0) {
            // TODO: what if unrenderedMath is already set?
            unrenderedMath = doc.markText(from, to);
          } else {
            var range = doc.markText(from, to, {replacedWith: elem,
                                                clearOnEnter: false});
            CodeMirror.on(range, "beforeCursorEnter", function() {
              var fromTo = range.find();
              console.log("beforeCursorEnter", fromTo, range);
              range.clear();
              unrenderedMath = doc.markText(fromTo.from, fromTo.to);
            });
          }
        });
      }

      // TODO: multi line $...$. Needs an approach similar to overlay modes.
      function processLine(lineHandle) {
        var text = lineHandle.text;
        var line = doc.getLineNumber(lineHandle);
        console.log("processLine", line, text);

        var formula = /\$.+?\${1,2}/g; // TODO: tighten, \(..\) & \[..\]                                                                                                                                                                                                                                            
        var match;
        while((match = formula.exec(text)) != null) {
          var fromCh = match.index;
          var toCh = fromCh + match[0].length;
          processMath({line: line, ch: fromCh}, {line: line, ch: toCh});
        }
      }

      /*editor.on("renderLine", function(editor, line, element) {
        console.log("renderLine", line, element);
        window.lll = line;
      });*/

      // Documents don't batch "change" events, so should never have .next.
      CodeMirror.on(doc, "change", function processChange(doc, changeObj) {
        console.log("change", changeObj);
        window.ccc = changeObj;
        // changeObj.{from,to} are pre-change coordinates; adding text.length 
        // (number of inserted lines) is a conservative(?) fix.
        doc.eachLine(changeObj.from.line,
                     changeObj.to.line + changeObj.text.length + 1,
                     processLine);
        if("next" in changeObj) {
          alert("next");
          processChange(changeObj.next);
        }
      });

      editor.on("cursorActivity", function(doc) {
        // TODO: selection behavior?
        var cursor = doc.getCursor();
        if (unrenderedMath == null) {
          return;
        }
        var range = unrenderedMath.find();
        console.log("cursorActivity", cursor, range.from, range.to);
        if(posCmp(range.from, cursor) > 0 && posCmp(cursor, range.to) > 0) {
          return;
        }
        processMath(range.from, range.to);
        unrenderedMath = null;
      });

      doc.eachLine(processLine);
    </script>
  </body>
</html>
